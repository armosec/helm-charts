name: 02-E2E Test helm chart
on:
  workflow_dispatch:
    inputs:
      BRANCH:
        description: 'helm chart branch name'
        required: false
        default: 'main'
        type: string
      TESTS_BRANCH:
        description: 'tests branch name'
        required: false
        default: 'master'
        type: string
      KS_BRANCH:
        required: false
        default: 'release'
        type: string
        description: 'kubescape branch name'
      CHARTS_NAME:
        type: choice
        description: 'What chart do you want to test?'
        options:
          - kubescape-operator
          - rapid7-operator

  workflow_call:
    inputs:
      BRANCH:
        required: false
        default: 'main'
        type: string
        description: 'helm chart branch name'
      TESTS_BRANCH:
        required: false
        default: 'master'
        type: string
        description: 'tests branch name'
      KS_BRANCH:
        required: false
        default: 'release'
        type: string
        description: 'kubescape branch name'
      CHARTS_NAME:
        required: false
        default: 'kubescape-operator'
        type: string
        description: 'chart name to test'

jobs:
  e2e-test:
    strategy:
      fail-fast: false
      matrix:
        test: [
              basic_incident_presented,
              cadr_incident_presented,
              kdr_response_by_user,
              kdr_runtime_policies_configurations,
              kdr_runtime_policies_configurations_no_cdr,
              ks_microservice_create_2_cronjob_mitre_and_nsa_proxy,
              ks_microservice_cronjob,
              ks_microservice_on_demand,
#              network_policy,
#              network_policy_data_appended,
              network_policy_known_servers,
              network_policy_multiple_replicas,
#              network_policy_pod_restarted,
              relevancy_disabled_installation,
              relevancy_enabled_stop_sniffing,
              relevancy_fix_vuln,
              relevancy_golang,
              relevancy_golang_dynamic,
              relevancy_java,
              relevancy_java_and_python,
              relevancy_large_image,
              relevancy_python,
              relevancy_storage_disabled,
              relevantCVEs,
              relevant_data_is_appended,
              scan_compliance_score,
              synchronizer,
              synchronizer_proxy,
              synchronizer_reconciliation,
#              test_registry_scanning,
              vuln_scan_proxy,
              vuln_scan_triggering_with_cron_job,
            ]

    runs-on: ubuntu-latest
    steps:

      # - name: echo GitHub var - dev
      #   id: github_context_step
      #   run: echo '${{ toJSON(github) }}'

      - name: Checkout systests repo
        uses: actions/checkout@v3
        with:
          repository: armosec/system-tests
          ref: ${{ inputs.TESTS_BRANCH }}
          path: .

      - uses: actions/setup-python@v4
        name: installing python 3.9
        with:
          python-version: '3.9'
          cache: 'pip'

      - name: create env
        run: ./create_env.sh

      - name: Generate uuid
        id: uuid
        run: |
          echo "RANDOM_UUID=systests-$(uuidgen)" >> $GITHUB_OUTPUT

      - name: Create k8s Kind Cluster
        id: kind-cluster-install
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: ${{ steps.uuid.outputs.RANDOM_UUID }}

      - name: Parse Multi-Prod Client Mapping (JSON Secret)
        id: parse-multi-prod-client-mapping
        env:
          MULTI_PROD_CLIENT_MAPPING: ${{ secrets.MULTI_PROD_CLIENT_MAPPING }}
        run: |
          # Make parsing resilient to missing/invalid MULTI_PROD_CLIENT_MAPPING.
          # If the secret is empty or not valid JSON, set empty outputs and continue without failing the job.
          if [ -z "$MULTI_PROD_CLIENT_MAPPING" ]; then
            echo "MULTI_PROD_CLIENT_MAPPING is empty or not set; skipping parse"
            echo "CLIENT_ID_PROD_US_EAST_1=" >> $GITHUB_OUTPUT
            echo "SECRET_KEY_PROD_US_EAST_1=" >> $GITHUB_OUTPUT
          else
            # Ensure the MULTI_PROD_CLIENT_MAPPING contains valid JSON.
            if ! echo "$MULTI_PROD_CLIENT_MAPPING" | jq -e . >/dev/null 2>&1; then
              echo "MULTI_PROD_CLIENT_MAPPING is present but not valid JSON; skipping parse"
              echo "CLIENT_ID_PROD_US_EAST_1=" >> $GITHUB_OUTPUT
              echo "SECRET_KEY_PROD_US_EAST_1=" >> $GITHUB_OUTPUT
            else
              # Parse the JSON secret and extract production credentials for US_EAST_1
              # Expected JSON structure:
              # { "armo_prod_us_east_1": { "client_id": "...", "secret_key": "..." }, ... }
              CLIENT_ID_PROD_US_EAST_1=$(echo "$MULTI_PROD_CLIENT_MAPPING" | jq -r '."armo_prod_us_east_1".client_id // empty')
              SECRET_KEY_PROD_US_EAST_1=$(echo "$MULTI_PROD_CLIENT_MAPPING" | jq -r '."armo_prod_us_east_1".secret_key // empty')

              # Mask secrets in logs
              [[ -n "$SECRET_KEY_PROD_US_EAST_1" ]] && echo "::add-mask::$SECRET_KEY_PROD_US_EAST_1"

              # Set outputs for downstream steps
              echo "CLIENT_ID_PROD_US_EAST_1=$CLIENT_ID_PROD_US_EAST_1" >> $GITHUB_OUTPUT
              echo "SECRET_KEY_PROD_US_EAST_1=$SECRET_KEY_PROD_US_EAST_1" >> $GITHUB_OUTPUT
            fi
          fi

      - name: run-tests
        env:
          CUSTOMER: ${{ secrets.CUSTOMER }}
          USERNAME: ${{ secrets.USERNAME }}
          PASSWORD: ${{ secrets.PASSWORD }}
          CLIENT_ID: ${{ secrets.CLIENT_ID_PROD }}
          SECRET_KEY: ${{ secrets.SECRET_KEY_PROD }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
          QUAY_REGISTRY_ACCESS_TOKEN: "${{ secrets.QUAY_REGISTRY_ACCESS_TOKEN }}"
          AZURE_REGISTRY_ACCESS_TOKEN: "${{ secrets.AZURE_REGISTRY_ACCESS_TOKEN }}"
          AWS_REGISTRY_SECRET_KEY: "${{ secrets.AWS_REGISTRY_SECRET_KEY }}"
          GOOGLE_REGISTRY_KEY: "${{ secrets.GOOGLE_REGISTRY_KEY }}"
        run: |
          echo "Test history:"
          echo " ${{ matrix.test }} " >/tmp/testhistory
          cat /tmp/testhistory
          source systests_python_env/bin/activate

          echo "Selected chart: ${{ inputs.CHARTS_NAME }}"

          if [ "${{ inputs.CHARTS_NAME }}" = "rapid7-operator" ]; then
            BACKEND="armo-prod-us-east-1"
            # Use armo_prod_us_east_1 credentials for rapid7-operator
            export CLIENT_ID="${{ steps.parse-multi-prod-client-mapping.outputs.CLIENT_ID_PROD_US_EAST_1 }}"
            export SECRET_KEY="${{ steps.parse-multi-prod-client-mapping.outputs.SECRET_KEY_PROD_US_EAST_1 }}"
          else
            BACKEND="production"
            # Use default production credentials
            export CLIENT_ID="${{ secrets.CLIENT_ID_PROD }}"
            export SECRET_KEY="${{ secrets.SECRET_KEY_PROD }}"
          fi

          python3 systest-cli.py  \
          -t ${{ matrix.test }}   \
          -b "$BACKEND"        \
          -c CyberArmorTests      \
          --logger DEBUG          \
          --kwargs helm_branch=${{ inputs.BRANCH }} ks_branch=${{ inputs.KS_BRANCH }} charts_name=${{ inputs.CHARTS_NAME }} charts_repo=${{ github.repository }}

          deactivate

      - name: Test Report
        uses: mikepenz/action-junit-report@v3
        if: always() # always run even if the previous step fails
        with:
          report_paths: '**/results_xml_format/**.xml'
